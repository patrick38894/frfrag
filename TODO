Note: Due on the 5th of June. (13 days remain).

Broad goals
-----------
* Print and run test cases:
    * Minimal shader
    * Color
    * Overload math
    * Operators for vector math
    * Region
    * Mandelbrot
    * Newton fractal
    * Voronoi cells
    * Raindrops/ripples
    * Starfield

* Add dependency handling; allow Exprs with static dependencies to have those dependencies declared inline in the Declarations section.
* Follow the development of the mandelbrot (and other test shaders) with some writeups.
* Use pipes to connect GLSL input stream to output.
* Make a "timed pipe" that reads an input stream gradually and implements FRP on the GLFW inputs.
* Make all FRP primitives.
    * Ev prims
    * Beh prims
* "Compile" a shader - extract static declarations and compute them once,
    unfold finite recursion, convert things to SSA, applies reduction rules, etc.
* Add structure/type checker.


Pipeline
--------
Haskell exprs (program description) -> (Eventually typecheck) -> PrettyPrint -> Bind to uniform pipe output

GLSL inputs/Time -> Event/Behavior processors -> Bind to uniform pipe input

Main loop: handle input and output between the pipes, refresh clock/screen


Second-order
------------
* Control structures
    * Stream a. Potentially infinite stream of Expr a.
    * ++: Put one string before another. When using Foldr/Foldl, use the same initializer/accumulator.
    * Enumerate: Make a Stream Int, in forward or reverse fashion (use Enum class to overload [1..])
    * Map: Given a -> b, Stream a, make Stream b
    * Foldr/Foldl: Given a -> acc -> acc, acc, stream a, make an acc
    * Scanl/Scanr: Stream a -> Stream acc basically
    * TailRecurse: Given base cases (a), recursion op (e.g. decrement), function b->a->b,
        compute function a -> b that starts with inputs a and b0
        computes some b with it using b0 and a, and stores b0 and a for the next iteration.
    * Iterate: Make While loop with predicate.
