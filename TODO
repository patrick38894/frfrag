Language level
--------------
* Swizzle, for Exp Vec -> Exp Vec and Exp Vec -> Exp Sca,
    and swizzle for lvalues (in declaration and assignment).
    Written as normal functions, these should work out.
    (But the type representations might need some dependent typing?)
* Struct as Rep. Basic ADTs.
* Unify func and proc, to faciliate fake recursion below.
* Make it possible to make a block of Decl, which simply get listed (no brace/indent). 

Second-order
------------
(Can't be included directly, but bake to Exp, Func, etc)

* Lambda abstraction - rewrite a term into an expression, eventually producing an expression via application.
    * Lambda as rewrite: rewrite until it becomes an expression ("finite recursion"). (Application)
    * Lambda as function: Lambda with n top-level lambda terms -> Function with n+1 args (Promotion)
        (Recurse to figure out lower-level functions, and define them as well). 
* Control structures
    * Stream a. Potentially infinite stream of a.
    * ++: Put one string before another. When using Foldr/Foldl, use the same initializer/accumulator.
    * Enumerate: Make a Stream Int, in forward or reverse fashion (use Enum class to overload [1..])
    * Map: Given a -> b, Stream a, make Stream b
    * Foldr/Foldl: Given a -> acc -> acc, acc, stream a, make an acc
    * Scanl/Scanr: Stream a -> Stream acc basically
    * TailRecurse: Given base cases (a), recursion op (e.g. decrement), function b->a->b,
        compute function a -> b that starts with inputs a and b0
        computes some b with it using b0 and a, and stores b0 and a for the next iteration.
    * Iterate: Make While loop with predicate.
